<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>転生チェス</title>
  <style>
    :root{
      --bg:#f6f6f6;
      --card:#ffffff;
      --text:#222;
      --muted:#666;
      --accent:#e53935;
      --border:#ddd;
      --light:#f0d9b5;
      --dark:#b58863;
      --shadow: 0 6px 18px rgba(0,0,0,.08);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif;
      background:var(--bg);
      color:var(--text);
    }
    .wrap{
      max-width: 760px;
      margin: 0 auto;
      padding: 18px 14px 28px;
    }
    h1{
      margin: 8px 0 10px;
      text-align:center;
      font-size: 34px;
      letter-spacing:.06em;
    }
    .message{
      text-align:center;
      color:var(--muted);
      margin: 6px 0 10px;
      min-height: 1.4em;
      font-size: 16px;
      font-weight: 600;
    }
    .turn{
      text-align:center;
      margin: 0 0 14px;
      font-weight: 700;
      color:#444;
    }

    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:16px;
      box-shadow: var(--shadow);
      padding: 14px;
    }

    /* setup */
    #setupContainer{
      display:flex;
      flex-direction:column;
      gap:12px;
      margin-top: 8px;
    }
    .row{
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
    }
    button{
      appearance:none;
      border:1px solid var(--border);
      background:#fff;
      padding: 12px 14px;
      border-radius: 12px;
      font-weight: 800;
      cursor:pointer;
      min-width: 130px;
      box-shadow: 0 4px 10px rgba(0,0,0,.06);
    }
    button.primary{
      background: var(--accent);
      border-color: var(--accent);
      color:#fff;
    }
    button.ghost{
      background:#fff;
      color:#222;
    }
    button:disabled{
      opacity:.5;
      cursor:not-allowed;
    }

    /* game */
    #gameContainer{ display:none; }
    .boardWrap{
      display:flex;
      justify-content:center;
    }
    #board{
      width: min(92vw, 520px);
      aspect-ratio: 1 / 1;
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      border: 2px solid #444;
      border-radius: 10px;
      overflow:hidden;
      background:#0000;
    }
    .sq{
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: clamp(20px, 6vw, 40px);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      position:relative;
    }
    .sq.light{ background: var(--light); }
    .sq.dark{ background: var(--dark); }
    .sq.sel::after{
      content:"";
      position:absolute;
      inset: 6%;
      border: 3px solid rgba(33,150,243,.85);
      border-radius: 10px;
      pointer-events:none;
    }
    .sq.hint::before{
      content:"";
      width: 18%;
      height: 18%;
      border-radius: 999px;
      background: rgba(0,0,0,.25);
      position:absolute;
      pointer-events:none;
    }
    .sq.captureHint::before{
      content:"";
      width: 70%;
      height: 70%;
      border-radius: 999px;
      border: 4px solid rgba(0,0,0,.25);
      position:absolute;
      pointer-events:none;
    }

    /* controls */
    .controls{
      display:flex;
      gap: 10px;
      justify-content:center;
      flex-wrap:wrap;
      margin-top: 14px;
    }

    .capturedGrid{
      margin-top: 14px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .capBox{
      padding: 12px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background:#fafafa;
      min-height: 92px;
    }
    .capTitle{
      font-weight: 900;
      margin-bottom: 8px;
    }
    .capList{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
    }
    .capPiece{
      font-size: 26px;
      padding: 6px 10px;
      border-radius: 10px;
      border:1px solid #ddd;
      background:#fff;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .capPiece.selected{
      outline: 3px solid rgba(33,150,243,.85);
      border-color: transparent;
    }

    /* modal */
    #overlay{
      display:none;
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.45);
      z-index: 50;
    }
    #dialog{
      display:none;
      position:fixed;
      inset:auto 50% 50% auto;
      transform: translate(50%, 50%);
      width: min(92vw, 520px);
      background:#fff;
      border-radius: 16px;
      box-shadow: var(--shadow);
      border:1px solid #ddd;
      padding: 14px;
      z-index: 60;
    }
    .dialogTitle{ font-weight: 900; margin: 4px 0 8px; }
    .dialogBody{ color:#444; margin-bottom: 10px; }
    .dialogRow{ display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap; }
    .small{ font-size: 12px; color:#666; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>転生チェス</h1>
    <div class="message" id="message"></div>
    <div class="turn" id="turn"></div>

    <div id="setupContainer" class="card">
      <div style="text-align:center;font-weight:900;">あなたの色を選んで開始</div>
      <div class="row">
        <button id="startWhite">白で開始</button>
        <button id="startBlack">黒で開始</button>
      </div>
      <div class="small" style="text-align:center;">
        ルール: 通常のチェス移動＋捕獲。転生は「自分が取られた駒」を消費して、空きマスにランダム（♕♖♗♘）で復活。
      </div>
    </div>

    <div id="gameContainer" class="card">
      <div class="boardWrap">
        <div id="board" aria-label="chess board"></div>
      </div>

      <div class="controls">
        <button id="resurrectBtn" class="primary">転生する</button>
        <button id="resetBtn" class="ghost">リセット</button>
      </div>

      <div class="capturedGrid">
        <div class="capBox">
          <div class="capTitle">白の捕獲済み（白が取られた）</div>
          <div class="capList" id="capWhite"></div>
        </div>
        <div class="capBox">
          <div class="capTitle">黒の捕獲済み（黒が取られた）</div>
          <div class="capList" id="capBlack"></div>
        </div>
      </div>
    </div>
  </div>

  <div id="overlay"></div>
  <div id="dialog" role="dialog" aria-modal="true">
    <div class="dialogTitle">転生</div>
    <div class="dialogBody" id="dialogText"></div>
    <div class="dialogRow">
      <button id="cancelRes" class="ghost">キャンセル</button>
    </div>
  </div>

<script>
(() => {
  // ---------- DOM ----------
  const setupContainer = document.getElementById('setupContainer');
  const gameContainer  = document.getElementById('gameContainer');
  const boardEl        = document.getElementById('board');
  const messageEl      = document.getElementById('message');
  const turnEl         = document.getElementById('turn');
  const capWhiteEl     = document.getElementById('capWhite');
  const capBlackEl     = document.getElementById('capBlack');

  const startWhiteBtn  = document.getElementById('startWhite');
  const startBlackBtn  = document.getElementById('startBlack');
  const resetBtn       = document.getElementById('resetBtn');
  const resurrectBtn   = document.getElementById('resurrectBtn');

  const overlay        = document.getElementById('overlay');
  const dialog         = document.getElementById('dialog');
  const dialogText     = document.getElementById('dialogText');
  const cancelResBtn   = document.getElementById('cancelRes');

  // ---------- Game State ----------
  let playerColor = null; // 'white' | 'black'
  let currentTurn = 'white';
  let board = Array(64).fill(null);

  let selected = null; // index of selected on-board piece
  let legalHints = new Set(); // destination indexes
  let captureHints = new Set();

  // Resurrection
  let isResurrectionMode = false;
  let selectedCapturedPiece = null; // {type,color} from capturedPieces[playerColor]

  const capturedPieces = {
    white: [], // pieces that were captured from white
    black: []  // pieces that were captured from black
  };

  const PIECE_UNI = {
    white: { king:'♔', queen:'♕', rook:'♖', bishop:'♗', knight:'♘', pawn:'♙' },
    black: { king:'♚', queen:'♛', rook:'♜', bishop:'♝', knight:'♞', pawn:'♟' }
  };

  function pieceAt(i){ return board[i]; }
  function inBounds(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
  function idxToRC(i){ return { r: Math.floor(i/8), c: i%8 }; }
  function rcToIdx(r,c){ return r*8 + c; }

  function opposite(color){ return color==='white' ? 'black' : 'white'; }

  // ---------- Setup ----------
  function initBoard() {
    board = Array(64).fill(null);

    // Helper
    const set = (r,c,type,color) => board[rcToIdx(r,c)] = ({type,color});

    // Black back rank
    set(0,0,'rook','black'); set(0,1,'knight','black'); set(0,2,'bishop','black'); set(0,3,'queen','black');
    set(0,4,'king','black'); set(0,5,'bishop','black'); set(0,6,'knight','black'); set(0,7,'rook','black');
    // Black pawns
    for(let c=0;c<8;c++) set(1,c,'pawn','black');

    // White pawns
    for(let c=0;c<8;c++) set(6,c,'pawn','white');
    // White back rank
    set(7,0,'rook','white'); set(7,1,'knight','white'); set(7,2,'bishop','white'); set(7,3,'queen','white');
    set(7,4,'king','white'); set(7,5,'bishop','white'); set(7,6,'knight','white'); set(7,7,'rook','white');
  }

  // ---------- Rendering ----------
  function renderBoard() {
    boardEl.innerHTML = '';
    for (let i=0;i<64;i++){
      const {r,c} = idxToRC(i);
      const sq = document.createElement('div');
      sq.className = 'sq ' + ((r+c)%2===0 ? 'light' : 'dark');
      sq.dataset.index = String(i);

      if (selected === i) sq.classList.add('sel');
      if (legalHints.has(i)) sq.classList.add('hint');
      if (captureHints.has(i)) sq.classList.add('captureHint');

      const p = pieceAt(i);
      if (p) sq.textContent = PIECE_UNI[p.color][p.type];

      boardEl.appendChild(sq);
    }
  }

  function renderCapturedPieces() {
    capWhiteEl.innerHTML = '';
    capBlackEl.innerHTML = '';

    const renderList = (color, el) => {
      capturedPieces[color].forEach((p, idx) => {
        const sp = document.createElement('span');
        sp.className = 'capPiece';
        sp.textContent = PIECE_UNI[p.color][p.type];
        sp.title = `${color}の捕獲済み: ${p.type}`;

        // 転生モード中：自分の捕獲駒だけ選べる
        sp.addEventListener('click', () => {
          if (!isResurrectionMode) return;
          if (currentTurn !== playerColor) return;
          if (color !== playerColor) return;

          // select
          selectedCapturedPiece = p;
          // UI selection marker
          [...el.querySelectorAll('.capPiece')].forEach(n => n.classList.remove('selected'));
          sp.classList.add('selected');

          messageEl.textContent = '置きたいマスを選んでください。';
          dialogText.textContent = '盤面の空きマスをタップして配置します（転生先はランダム）。';
        });

        el.appendChild(sp);
      });
    };

    renderList('white', capWhiteEl);
    renderList('black', capBlackEl);
  }

  function updateTurnUI() {
    turnEl.textContent = (currentTurn === 'white' ? '白のターン' : '黒のターン');
  }

  function updateResurrectButtonState() {
    // 転生は自分の手番で、かつ自分の捕獲駒があるときだけ押せる
    const can = playerColor && (currentTurn === playerColor) && (capturedPieces[playerColor].length > 0) && !isResurrectionMode;
    resurrectBtn.disabled = !can;
    resurrectBtn.style.display = 'inline-block'; // ★常に存在（リセットでも復帰）
  }

  function clearSelection() {
    selected = null;
    legalHints.clear();
    captureHints.clear();
  }

  // ---------- Move Rules (basic) ----------
  function getLegalMoves(fromIdx) {
    const p = pieceAt(fromIdx);
    if (!p) return {moves:new Set(), captures:new Set()};
    const {r,c} = idxToRC(fromIdx);
    const moves = new Set();
    const captures = new Set();

    const addRay = (dr,dc) => {
      let rr=r+dr, cc=c+dc;
      while(inBounds(rr,cc)){
        const to = rcToIdx(rr,cc);
        const q = pieceAt(to);
        if (!q) {
          moves.add(to);
        } else {
          if (q.color !== p.color) captures.add(to);
          break;
        }
        rr += dr; cc += dc;
      }
    };

    if (p.type === 'pawn') {
      const dir = (p.color === 'white') ? -1 : 1;
      const startRow = (p.color === 'white') ? 6 : 1;

      // forward 1
      const f1r = r + dir;
      if (inBounds(f1r,c)) {
        const f1 = rcToIdx(f1r,c);
        if (!pieceAt(f1)) moves.add(f1);
      }
      // forward 2
      const f2r = r + 2*dir;
      if (r === startRow && inBounds(f2r,c)) {
        const f1 = rcToIdx(r+dir,c);
        const f2 = rcToIdx(f2r,c);
        if (!pieceAt(f1) && !pieceAt(f2)) moves.add(f2);
      }
      // captures diagonals
      for (const dc of [-1, 1]) {
        const rr = r + dir, cc = c + dc;
        if (!inBounds(rr,cc)) continue;
        const to = rcToIdx(rr,cc);
        const q = pieceAt(to);
        if (q && q.color !== p.color) captures.add(to);
      }
    }

    if (p.type === 'knight') {
      const deltas = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
      for (const [dr,dc] of deltas) {
        const rr=r+dr, cc=c+dc;
        if (!inBounds(rr,cc)) continue;
        const to = rcToIdx(rr,cc);
        const q = pieceAt(to);
        if (!q) moves.add(to);
        else if (q.color !== p.color) captures.add(to);
      }
    }

    if (p.type === 'bishop' || p.type === 'queen') {
      addRay(-1,-1); addRay(-1,1); addRay(1,-1); addRay(1,1);
    }
    if (p.type === 'rook' || p.type === 'queen') {
      addRay(-1,0); addRay(1,0); addRay(0,-1); addRay(0,1);
    }
    if (p.type === 'king') {
      for (let dr=-1; dr<=1; dr++){
        for (let dc=-1; dc<=1; dc++){
          if (dr===0 && dc===0) continue;
          const rr=r+dr, cc=c+dc;
          if (!inBounds(rr,cc)) continue;
          const to = rcToIdx(rr,cc);
          const q = pieceAt(to);
          if (!q) moves.add(to);
          else if (q.color !== p.color) captures.add(to);
        }
      }
    }

    return {moves, captures};
  }

  function movePiece(fromIdx, toIdx) {
    const p = pieceAt(fromIdx);
    const q = pieceAt(toIdx);

    if (q) {
      // captured: q.color side loses a piece -> goes to capturedPieces[q.color]
      capturedPieces[q.color].push(q);
    }

    board[toIdx] = p;
    board[fromIdx] = null;
  }

  function switchTurn() {
    currentTurn = opposite(currentTurn);
    updateTurnUI();
    updateResurrectButtonState();
  }

  // ---------- Resurrection ----------
  function openDialog(text) {
    dialogText.textContent = text;
    overlay.style.display = 'block';
    dialog.style.display = 'block';
  }
  function closeDialog() {
    overlay.style.display = 'none';
    dialog.style.display = 'none';
  }

  function enterResurrectionMode() {
    if (!playerColor) return;
    if (currentTurn !== playerColor) return;
    if (capturedPieces[playerColor].length === 0) return;

    isResurrectionMode = true;
    selectedCapturedPiece = null;
    clearSelection();
    renderBoard();
    renderCapturedPieces();
    updateResurrectButtonState();

    messageEl.textContent = '転生させたい駒を選んでください。';
    openDialog('まず捕獲済み（自分が取られた）駒をタップ → 次に盤面の空きマスをタップ。転生先はランダム（♕♖♗♘）です。');
  }

  function cancelResurrection() {
    isResurrectionMode = false;
    selectedCapturedPiece = null;
    messageEl.textContent = '';
    closeDialog();
    renderCapturedPieces();
    updateResurrectButtonState();
  }

  function getRandomResurrectionType() {
    // 等確率（必要なら重み付けしてOK）
    const types = ['queen','rook','bishop','knight'];
    return types[Math.floor(Math.random() * types.length)];
  }

  function handleResurrectionPlacement(toIdx) {
    if (!isResurrectionMode) return;
    if (!selectedCapturedPiece) return; // 捕獲駒未選択なら置けない
    if (pieceAt(toIdx)) return; // 空きマスのみ

    // ランダム転生先
    const newType = getRandomResurrectionType();
    board[toIdx] = { type: newType, color: playerColor };

    // 捕獲リストから1個消費（同一オブジェクト参照で探す）
    const list = capturedPieces[playerColor];
    const k = list.indexOf(selectedCapturedPiece);
    if (k !== -1) list.splice(k, 1);

    // 状態リセット
    isResurrectionMode = false;
    selectedCapturedPiece = null;
    closeDialog();
    messageEl.textContent = '';

    renderCapturedPieces();
    clearSelection();
    renderBoard();
    switchTurn();
  }

  // ---------- Input ----------
  function onBoardClick(e) {
    const sq = e.target.closest('.sq');
    if (!sq) return;
    const idx = Number(sq.dataset.index);

    // ★最優先：転生モードで捕獲駒選択済みなら「置く」
    if (isResurrectionMode && selectedCapturedPiece) {
      handleResurrectionPlacement(idx);
      return;
    }
    // 転生モードだが捕獲駒未選択なら盤面は無視
    if (isResurrectionMode) return;

    const p = pieceAt(idx);

    // すでに選択中で、そこが合法手なら移動
    if (selected !== null && (legalHints.has(idx) || captureHints.has(idx))) {
      movePiece(selected, idx);
      clearSelection();
      renderCapturedPieces();
      renderBoard();
      switchTurn();
      return;
    }

    // 自分の手番の自分の駒だけ選択できる
    if (!p) {
      clearSelection();
      renderBoard();
      return;
    }
    if (p.color !== currentTurn) return;
    // 「プレイヤー色」制限を入れるならここで:
    // if (p.color !== playerColor) return;

    selected = idx;
    const {moves, captures} = getLegalMoves(idx);
    legalHints = moves;
    captureHints = captures;

    renderBoard();
  }

  // ---------- Reset / Start ----------
  function startGame(color) {
    playerColor = color;
    currentTurn = 'white';
    capturedPieces.white = [];
    capturedPieces.black = [];
    isResurrectionMode = false;
    selectedCapturedPiece = null;
    clearSelection();

    initBoard();
    renderBoard();
    renderCapturedPieces();
    updateTurnUI();
    messageEl.textContent = '';
    closeDialog();

    setupContainer.style.display = 'none';
    gameContainer.style.display = 'block';

    // ★転生ボタンは常に復帰
    resurrectBtn.style.display = 'inline-block';
    updateResurrectButtonState();
  }

  function resetGame() {
    // 状態初期化
    playerColor = null;
    currentTurn = 'white';
    capturedPieces.white = [];
    capturedPieces.black = [];
    isResurrectionMode = false;
    selectedCapturedPiece = null;
    clearSelection();

    // ★UIの初期化（転生ボタンも必ず復帰）
    resurrectBtn.style.display = 'inline-block';
    resurrectBtn.disabled = true;
    messageEl.textContent = '';
    turnEl.textContent = '';
    closeDialog();

    // 表示切替
    gameContainer.style.display = 'none';
    setupContainer.style.display = 'flex';

    // 盤面の掃除
    boardEl.innerHTML = '';
    capWhiteEl.innerHTML = '';
    capBlackEl.innerHTML = '';
  }

  // ---------- Wire up ----------
  boardEl.addEventListener('click', onBoardClick);
  startWhiteBtn.addEventListener('click', () => startGame('white'));
  startBlackBtn.addEventListener('click', () => startGame('black'));
  resetBtn.addEventListener('click', resetGame);
  resurrectBtn.addEventListener('click', enterResurrectionMode);
  cancelResBtn.addEventListener('click', cancelResurrection);
  overlay.addEventListener('click', cancelResurrection);

  // initial
  resetGame();
})();
</script>
</body>
</html>
