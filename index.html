<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1"
  />
  <title>転生チェス（Reincarnation Chess）MVP</title>
  <style>
    :root { --bg:#f6f6f6; --card:#fff; --ink:#111; --muted:#6b7280; }
    html,body { margin:0; background:var(--bg); color:var(--ink); font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
    .wrap { max-width:1100px; margin:0 auto; padding:16px; }
    .grid { display:grid; gap:16px; grid-template-columns: 1fr; }
    @media(min-width: 960px){ .grid { grid-template-columns: 2fr 1fr; } }
    .card { background:var(--card); border-radius:16px; box-shadow:0 6px 16px rgba(0,0,0,.06); padding:16px; }
    .row { display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .btn { border:1px solid #e5e7eb; background:#fff; border-radius:999px; padding:6px 12px; cursor:pointer; }
    .btn.primary { background:#111; color:#fff; }
    .small { font-size:12px; color:var(--muted); }
    .queue li { display:flex; align-items:center; gap:8px; font-size:14px; }
    .dot { width:8px; height:8px; border-radius:999px; display:inline-block; }
    .dot.w { background:#3b82f6; } .dot.b { background:#ef4444; }
    .log { max-height:260px; overflow:auto; font-size:14px; }
    .title { font-weight: 700; font-size: 22px; }
    .controls { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .seg { display:flex; gap:4px; border:1px solid #e5e7eb; border-radius:999px; padding:3px; background:#fff; }
    .seg button { padding:4px 10px; border:none; background:transparent; border-radius:999px; cursor:pointer; }
    .seg button.active { background:#111; color:#fff; }
    .status { font-size:14px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="row" style="margin-bottom:10px">
      <div class="title">転生チェス（Reincarnation Chess）MVP</div>
      <div class="controls">
        <button id="btn-reset" class="btn">新規ゲーム</button>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <div id="board"></div>
        <div class="row" style="margin-top:10px">
          <div class="status" id="status">白の手番</div>
          <div class="controls">
            <div class="small">昇格先</div>
            <div class="seg" id="promo-seg">
              <button data-p="q" class="active">クイーン</button>
              <button data-p="r">ルーク</button>
              <button data-p="b">ビショップ</button>
              <button data-p="n">ナイト</button>
            </div>
          </div>
        </div>
      </div>

      <div class="card">
        <h3 style="margin:0 0 8px 0; font-size:16px">転生待ちキュー</h3>
        <ul id="queue" class="queue" style="margin:0; padding-left:16px"></ul>
        <p class="small">※ キングには転生しません。配置は自陣最奥列の空きマスへ。元種と異なるランダムな別種に変化します。</p>

        <h3 style="margin:16px 0 8px 0; font-size:16px">ログ</h3>
        <ol id="log" class="log" style="margin:0; padding-left:18px"></ol>

        <h3 style="margin:16px 0 8px 0; font-size:16px">ルール（MVP）</h3>
        <ul class="small" style="margin:0; padding-left:18px; line-height:1.5">
          <li>通常チェス + 「手番開始時の転生」フェーズ。</li>
          <li>自分が直前までに取られていれば、1体だけ自陣最奥列の空きへ蘇生。</li>
          <li>蘇生する種はキング除外の5種から、元種と異なるランダム。</li>
          <li>空きがなければスキップ（次回に持ち越し）。</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- アプリ本体 -->
  <script type="module">
    // ライブラリをCDNから読み込み（ESM）
    import React, { useMemo, useRef, useState, useEffect } from "https://esm.sh/react@18.2.0";
    import { createRoot } from "https://esm.sh/react-dom@18.2.0/client";
    import { Chess } from "https://esm.sh/chess.js@1.0.0";
    import { Chessboard } from "https://esm.sh/react-chessboard@4.4.4?deps=react@18.2.0,react-dom@18.2.0";

    // --- 便利系 ------------------------------------------------------------
    const HUMAN_COLOR = "w"; // 人間は白
    const BACK_RANK = {
      w: ["a1","b1","c1","d1","e1","f1","g1","h1"],
      b: ["a8","b8","c8","d8","e8","f8","g8","h8"],
    };
    const PIECE_LABEL = { p:"ポーン", n:"ナイト", b:"ビショップ", r:"ルーク", q:"クイーン", k:"キング" };
    const pieceName = (t) => PIECE_LABEL[t] ?? t;
    const pick = (arr) => arr.length ? arr[Math.floor(Math.random()*arr.length)] : undefined;
    const opposite = (c) => c === "w" ? "b" : "w";

    const expectedReincarnationValue = (original) => {
      const pool = ["p","n","b","r","q"].filter(t => t !== original);
      const val = { p:1, n:3, b:3, r:5, q:9 };
      return pool.reduce((a,t)=>a+val[t],0)/pool.length;
    };

    // --- React アプリ ------------------------------------------------------
    function App(){
      const [game, setGame] = useState(()=> new Chess());
      const [fen, setFen] = useState(()=> new Chess().fen());
      const [queue, setQueue] = useState([]); // {color, original, id}
      const [log, setLog] = useState(["新規ゲーム開始。白の手番。"]);
      const [aiThinking, setAiThinking] = useState(false);
      const [promo, setPromo] = useState("q"); // q/r/b/n

      // DOM要素
      useEffect(()=>{
        // 昇格UI
        const seg = document.getElementById("promo-seg");
        seg.querySelectorAll("button").forEach(btn=>{
          btn.addEventListener("click", ()=>{
            seg.querySelectorAll("button").forEach(b=>b.classList.remove("active"));
            btn.classList.add("active");
            setPromo(btn.dataset.p);
          });
        });
        // リセット
        document.getElementById("btn-reset").addEventListener("click", resetGame);
      },[]);

      // ステータス表示
      useEffect(()=>{
        const el = document.getElementById("status");
        let text = (game.isCheckmate() && "チェックメイト！")
          || (game.isStalemate() && "ステイルメイト")
          || (game.isDraw() && "引き分け")
          || ((game.turn()==="w"?"白":"黒") + " の手番");
        if (game.isCheck() && !game.isCheckmate()) text += "（チェック中）";
        if (aiThinking) text += "（AI思考中…）";
        el.textContent = text;
      },[fen, aiThinking]);

      // キュー表示
      useEffect(()=>{
        const ul = document.getElementById("queue");
        ul.innerHTML = "";
        if (!queue.length) {
          const li = document.createElement("li");
          li.innerHTML = '<span class="small" style="color:var(--muted)">（なし）</span>';
          ul.appendChild(li);
          return;
        }
        queue.forEach((q, i)=>{
          const li = document.createElement("li");
          li.innerHTML = `<span class="dot ${q.color}"></span> ${i+1}. ${q.color==="w"?"白":"黒"}：${pieceName(q.original)} が次手番に転生`;
          ul.appendChild(li);
        });
      },[queue]);

      // ログ表示
      useEffect(()=>{
        const ol = document.getElementById("log");
        ol.innerHTML = "";
        log.forEach(item=>{
          const li = document.createElement("li");
          li.textContent = item;
          ol.appendChild(li);
        });
      },[log]);

      function resetGame(){
        const g = new Chess();
        setGame(g);
        setFen(g.fen());
        setQueue([]);
        setLog(["新規ゲーム開始。白の手番。"]);
        setAiThinking(false);
      }

      // 転生（手番開始時）
      function performReincarnationIfAny(color){
        const idx = queue.findIndex(q => q.color === color);
        if (idx === -1) return false;

        const emptyBack = BACK_RANK[color].filter(sq => !game.get(sq));
        if (!emptyBack.length) return false;

        const item = queue[idx];
        const newType = pick(["p","n","b","r","q"].filter(t => t !== item.original)) || "n";
        const chosen = pick(emptyBack);
        // 直接配置（castling権などは変更しない）
        game.put({ type:newType, color }, chosen);
        setFen(game.fen());

        const nextQ = queue.slice();
        nextQ.splice(idx,1);
        setQueue(nextQ);

        setLog(prev => [`【転生】${color==="w"?"白":"黒"}の${pieceName(item.original)}が ${chosen} に ${pieceName(newType)} として復活。`, ...prev]);
        return true;
      }

      // 着手適用（人間/AI共通）
      function applyMove(from, to, promotion){
        const res = game.move({ from, to, promotion });
        if (!res) return false;

        // 捕獲 → 待機キューへ
        if (res.captured){
          const capturedType = res.captured;   // 'p','n','b','r','q','k'
          const capturedColor = res.color === "w" ? "b" : "w";
          setQueue(q => [...q, { color: capturedColor, original: capturedType, id: `${Date.now()}-${Math.random()}` }]);
          setLog(prev => [`【捕獲】${res.color==="w"?"白":"黒"} が ${res.to} で ${capturedColor==="w"?"白":"黒"}の ${pieceName(capturedType)} を取った。`, ...prev]);
        }

        setLog(prev => [`【着手】${res.color==="w"?"白":"黒"}: ${res.san}`, ...prev]);
        setFen(game.fen());
        return true;
      }

      // --- AI 手番 ----------------------------------------------------------
      function aiMaterial(forColor){
        let score=0;
        for (const row of game.board()){
          for (const cell of row){
            if (!cell || cell.color !== forColor || cell.type === "k") continue;
            score += ({p:1,n:3,b:3,r:5,q:9})[cell.type];
          }
        }
        return score;
      }
      function aiEvaluateMove(move){
        const clone = new Chess(game.fen());
        const r = clone.move(move);
        if (!r) return -999;
        if (clone.isCheckmate()) return 1000;
        if (clone.isStalemate()) return 0;

        const mat = aiMaterial("b") - aiMaterial("w");
        const penalty = r.captured ? expectedReincarnationValue(r.captured) : 0;
        return mat - penalty*0.8;
      }
      function aiTurn(){
        if (game.game_over()) return;
        if (game.turn() !== "b") return;

        setAiThinking(true);

        // 手番開始：AI側の転生
        performReincarnationIfAny("b");
        setFen(game.fen());

        const moves = game.moves({ verbose:true });
        if (!moves.length){ setAiThinking(false); return; }

        // 1手読みで選択
        let best = moves[0], bestScore = -Infinity;
        for (const m of moves){
          const s = aiEvaluateMove(m);
          if (s > bestScore){ bestScore = s; best = m; }
        }

        // 着手
        applyMove(best.from, best.to, best.promotion);
        setAiThinking(false);

        // AIが指し終えたら、人間手番の開始＝転生を即時実行
        if (game.turn() === "w"){
          performReincarnationIfAny("w");
          setFen(game.fen());
        }
      }

      // --- 人間の入力（ドラッグ＆ドロップ） --------------------------------
      function onPieceDrop(sourceSquare, targetSquare){
        if (game.turn() !== HUMAN_COLOR) return false;

        // 昇格判定
        const moving = game.get(sourceSquare);
        const isPromo = moving?.type === "p" &&
          ((HUMAN_COLOR==="w" && /8$/.test(targetSquare)) || (HUMAN_COLOR==="b" && /1$/.test(targetSquare)));

        const ok = applyMove(sourceSquare, targetSquare, isPromo ? promo : undefined);
        if (!ok) return false;

        // 人間が指し終えたらAI手番へ（AI側の転生→着手）
        setTimeout(()=> aiTurn(), 180);
        return true;
      }

      // 初手番（白）の開始時：キューがあれば即転生（通常は何もなし）
      useEffect(()=>{
        if (game.turn() === "w") {
          performReincarnationIfAny("w");
          setFen(game.fen());
        }
        // eslint-disable-next-line
      },[]);

      // React描画
      return React.createElement(
        React.Fragment,
        null,
        React.createElement(Chessboard, {
          position: fen,
          onPieceDrop,
          boardWidth: Math.min(640, (typeof window!=="undefined" ? window.innerWidth : 640) - 48),
          showBoardNotation: true,
          arePremovesAllowed: false,
          customBoardStyle: { borderRadius: "16px" }
        })
      );
    }

    // マウント
    const root = createRoot(document.getElementById("board"));
    root.render(React.createElement(App));
  </script>
</body>
</html>
