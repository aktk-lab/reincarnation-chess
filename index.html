import React, { useEffect, useMemo, useRef, useState } from "react"; import { Chess } from "chess.js"; import { Chessboard } from "react-chessboard";

// --- 型定義 ---------------------------------------------------------------

type Color = "w" | "b";

type PieceType = "p" | "n" | "b" | "r" | "q" | "k";

interface QueueItem { color: Color; // 取られた側（= 次に蘇る側） original: PieceType; // 取られた駒の元種（kは来ない想定だが型として許容） id: string; // ログ用 }

// --- 定数 -----------------------------------------------------------------

const PIECE_VALUES: Record<Exclude<PieceType, "k">, number> = { p: 1, n: 3, b: 3, r: 5, q: 9, };

const BACK_RANK: Record<Color, string[]> = { w: ["a1","b1","c1","d1","e1","f1","g1","h1"], b: ["a8","b8","c8","d8","e8","f8","g8","h8"], };

const HUMAN_COLOR: Color = "w"; // 人間は白で固定（必要ならUIで切替可）

// --- 乱数ユーティリティ ---------------------------------------------------

function pickRandom<T>(arr: T[]): T | undefined { if (!arr.length) return undefined; const idx = Math.floor(Math.random() * arr.length); return arr[idx]; }

function drawReincarnatedType(original: PieceType): Exclude<PieceType, "k"> { const candidates: Exclude<PieceType, "k">[] = ["p", "n", "b", "r", "q"]; // キング除外 const filtered = candidates.filter((t) => t !== original); return pickRandom(filtered) || "n"; // 事故防止 }

// 期待値（相手に蘇生を与えるデメリット） function expectedReincarnationValue(original: PieceType): number { const candidates: Exclude<PieceType, "k">[] = ["p", "n", "b", "r", "q"].filter( (t) => t !== original ) as Exclude<PieceType, "k">[]; const sum = candidates.reduce((acc, t) => acc + PIECE_VALUES[t], 0); return sum / candidates.length; }

// --- コンポーネント -------------------------------------------------------

export default function ReincarnationChessApp() { const [game, setGame] = useState(() => new Chess()); const [fen, setFen] = useState(game.fen()); const [queue, setQueue] = useState<QueueItem[]>([]); const [log, setLog] = useState<string[]>([]); const [aiThinking, setAiThinking] = useState(false); const [autoPromoteTo, setAutoPromoteTo] = useState<"q" | "r" | "b" | "n">("q"); const [showHints, setShowHints] = useState(true);

// FEN更新ヘルパ const syncFen = () => setFen(game.fen());

// 捕獲処理を監視するための直近ムーブ記録 const lastMoveRef = useRef<string | null>(null);

// 盤を初期化 const resetGame = () => { const g = new Chess(); setGame(g); setFen(g.fen()); setQueue([]); setLog(["新規ゲーム開始。白の手番。"]); setAiThinking(false); };

// --- 転生フェーズ：手番開始時に実行 ----------------------------------- const performReincarnationIfAny = (turn: Color) => { // キューから同色を1つだけ取り出す const idx = queue.findIndex((q) => q.color === turn); if (idx === -1) return false;

const item = queue[idx];
const newType = drawReincarnatedType(item.original);

// 最奥列の空きマスを探す
const emptyBack = BACK_RANK[turn].filter((sq) => game.get(sq) === null);
if (!emptyBack.length) {
  // 置けない → キューは維持
  return false;
}
const chosen = pickRandom(emptyBack)!;

// 直接盤に駒を置く（chess.js は put をサポート）
// @ts-ignore - 型定義にないがランタイムには存在
const ok: boolean = game.put({ type: newType, color: turn }, chosen);
if (!ok) {
  return false; // 念のため
}

// ログと状態更新
const newQueue = [...queue];
newQueue.splice(idx, 1);
setQueue(newQueue);
setLog((prev) => [
  `【転生】${turn === "w" ? "白" : "黒"}の${pieceName(item.original)}が ${squareLabel(chosen)} に ${pieceName(newType)} として復活。`,
  ...prev,
]);
syncFen();
return true;

};

// ヒューマンの手番開始時にも転生を実行 useEffect(() => { const turn = game.turn() as Color; performReincarnationIfAny(turn); syncFen(); // eslint-disable-next-line react-hooks/exhaustive-deps }, [game]);

// --- 手の適用 ----------------------------------------------------------- function safeGameMutate(mutator: (g: Chess) => void) { const g = new Chess(game.fen()); mutator(g); setGame(g); setFen(g.fen()); }

// 捕獲があればキューに積む const enqueueIfCapture = (moveSan: string, colorJustMoved: Color) => { // SANに "x" があれば捕獲（厳密には不十分だが簡易判定） if (!moveSan.includes("x")) return; // 直前手の反対側が取られた側 const capturedColor: Color = colorJustMoved === "w" ? "b" : "w";

// 何が取られたかを盤面差分から推定するのは難しいので、
// chess.js の move 結果を使うため、lastMoveRef にLANを保持しておくのが簡単。

};

// 実際には chess.js の move 返却値を使って確実に取得する const applyMove = (from: string, to: string, promotion?: string) => { let moveResult: any = null; safeGameMutate((g) => { try { moveResult = g.move({ from, to, promotion }); } catch (e) { moveResult = null; } });

if (!moveResult) return false;

// 捕獲キュー
if (moveResult.captured) {
  const capturedType: PieceType = moveResult.captured;
  const nextColor: Color = moveResult.color === "w" ? "b" : "w"; // 取られた側
  const item: QueueItem = {
    color: nextColor,
    original: capturedType,
    id: `${Date.now()}-${Math.random()}`,
  };
  setQueue((q) => [...q, item]);
  setLog((prev) => [
    `【捕獲】${moveResult.color === "w" ? "白" : "黒"} が ${squareLabel(moveResult.to)} で ${enemyColorLabel(nextColor)}の ${pieceName(capturedType)} を取った。`,
    ...prev,
  ]);
}

setLog((prev) => [
  `【着手】${moveResult.color === "w" ? "白" : "黒"}: ${moveResult.san}`,
  ...prev,
]);

setFen(game.fen());
return true;

};

// --- ユーザー入力（ドラッグ＆ドロップ） -------------------------------- const onPieceDrop = (sourceSquare: string, targetSquare: string) => { if ((game.turn() as Color) !== HUMAN_COLOR) return false;

const movingPiece = game.get(sourceSquare);
if (!movingPiece) return false;

const isPromotionMove =
  movingPiece.type === "p" &&
  ((HUMAN_COLOR === "w" && targetSquare.endsWith("8")) ||
    (HUMAN_COLOR === "b" && targetSquare.endsWith("1")));

const ok = applyMove(
  sourceSquare,
  targetSquare,
  isPromotionMove ? autoPromoteTo : undefined
);

if (!ok) return false;

// 相手（AI）の手番開始：AI側の転生→AI着手
window.setTimeout(() => {
  triggerAiTurn();
}, 200);

return true;

};

// --- AI --------------------------------------------------------------- // シンプル1手読み + 転生期待値ペナルティ function aiEvaluateMove(g: Chess, move: any): number { const clone = new Chess(g.fen()); const res = clone.move(move); if (!res) return -999;

// 素材点差（簡易）
const materialScore = material(clone, "b") - material(clone, "w");

// この手で相手に捕獲を与えたなら、相手の転生EVをペナルティ
let reincPenalty = 0;
if (res.captured) {
  reincPenalty = expectedReincarnationValue(res.captured as PieceType);
}

// チェックメイトボーナス/ピンチ
if (clone.isCheckmate()) return 1000;
if (clone.isStalemate()) return 0;

return materialScore - reincPenalty * 0.8; // 重みは適当

}

function material(g: Chess, forColor: Color): number { const board = g.board(); let score = 0; for (const row of board) { for (const cell of row) { if (!cell) continue; if (cell.color !== forColor) continue; if (cell.type === "k") continue; // @ts-ignore score += PIECE_VALUES[cell.type]; } } return score; }

const triggerAiTurn = () => { if (game.game_over()) return; if ((game.turn() as Color) !== opposite(HUMAN_COLOR)) return;

setAiThinking(true);

// まず転生
performReincarnationIfAny(game.turn() as Color);
syncFen();

// 合法手一覧
const moves = game.moves({ verbose: true });
if (!moves.length) {
  setAiThinking(false);
  return;
}

// 1手読みスコアリング
let best = moves[0];
let bestScore = -Infinity;
for (const m of moves) {
  const s = aiEvaluateMove(game, m);
  if (s > bestScore) {
    bestScore = s;
    best = m;
  }
}

// 着手
safeGameMutate((g) => {
  g.move(best);
});

// 捕獲ならキュー
if ((best as any).captured) {
  const capturedType: PieceType = (best as any).captured;
  const nextColor: Color = (best as any).color === "w" ? "b" : "w";
  const item: QueueItem = {
    color: nextColor,
    original: capturedType,
    id: `${Date.now()}-${Math.random()}`,
  };
  setQueue((q) => [...q, item]);
  setLog((prev) => [
    `【捕獲】AI(${(best as any).color === "w" ? "白" : "黒"}) が ${squareLabel((best as any).to)} で ${enemyColorLabel(nextColor)}の ${pieceName(capturedType)} を取った。`,
    ...prev,
  ]);
}

setLog((prev) => [
  `【着手】AI: ${(best as any).san}`,
  ...prev,
]);

setAiThinking(false);

};

// --- ユーティリティ ----------------------------------------------------- function pieceName(p: PieceType) { switch (p) { case "p": return "ポーン"; case "n": return "ナイト"; case "b": return "ビショップ"; case "r": return "ルーク"; case "q": return "クイーン"; case "k": return "キング"; default: return p; } } function squareLabel(sq: string) { return sq; } function enemyColorLabel(c: Color) { return c === "w" ? "白" : "黒"; } function opposite(c: Color): Color { return c === "w" ? "b" : "w"; }

const statusText = useMemo(() => { if (game.isCheckmate()) return "チェックメイト！"; if (game.isStalemate()) return "ステイルメイト"; if (game.isDraw()) return "引き分け"; if (game.isCheck()) return ${game.turn() === "w" ? "白" : "黒"} がチェック中; return ${game.turn() === "w" ? "白" : "黒"} の手番; }, [fen]);

// --- レイアウト --------------------------------------------------------- return ( <div className="min-h-screen w-full bg-neutral-100 text-neutral-900"> <div className="mx-auto max-w-6xl p-4 grid grid-cols-1 md:grid-cols-3 gap-4"> <div className="md:col-span-2"> <div className="flex items-center justify-between mb-2"> <h1 className="text-2xl font-bold">転生チェス（MVP）</h1> <div className="flex gap-2"> <button className="px-3 py-1 rounded-2xl shadow bg-white" onClick={resetGame}>新規ゲーム</button> <label className="px-3 py-1 rounded-2xl shadow bg-white flex items-center gap-2"> <input type="checkbox" checked={showHints} onChange={e=>setShowHints(e.target.checked)} /> ヒント </label> </div> </div>

<div className="rounded-2xl shadow bg-white p-3">
        <Chessboard
          position={fen}
          onPieceDrop={onPieceDrop}
          boardWidth={Math.min(600, typeof window!=="undefined" ? window.innerWidth - 32 : 600)}
          customBoardStyle={{ borderRadius: 16 }}
          customDarkSquareStyle={{}}
          customLightSquareStyle={{}}
          arePremovesAllowed={false}
          showBoardNotation={true}
          customArrows={[]}
          customSquareStyles={{}}
        />
        <div className="mt-3 flex items-center justify-between">
          <div className="text-sm">{statusText}{aiThinking ? "（AI思考中…）" : ""}</div>
          <div className="flex items-center gap-2 text-sm">
            <span>昇格先:</span>
            {(["q","r","b","n"] as const).map(t => (
              <button
                key={t}
                onClick={()=>setAutoPromoteTo(t)}
                className={`px-2 py-1 rounded-2xl border ${autoPromoteTo===t?"bg-neutral-900 text-white":"bg-white"}`}
              >{pieceName(t as PieceType)}</button>
            ))}
          </div>
        </div>
      </div>

      <div className="mt-4 grid grid-cols-1 md:grid-cols-2 gap-4">
        <div className="rounded-2xl shadow bg-white p-3">
          <h2 className="font-semibold mb-2">転生待ちキュー</h2>
          <ul className="space-y-1 text-sm">
            {queue.length===0 && <li className="text-neutral-500">（なし）</li>}
            {queue.map((q,i)=> (
              <li key={q.id} className="flex items-center gap-2">
                <span className={`inline-block w-2 h-2 rounded-full ${q.color==="w"?"bg-blue-500":"bg-rose-500"}`}></span>
                <span>{i+1}. {q.color==="w"?"白":"黒"}：{pieceName(q.original)} が次手番に転生</span>
              </li>
            ))}
          </ul>
          <p className="text-xs text-neutral-500 mt-2">※ キングには転生しません。配置は自陣最奥列の空きマスへ。元種と異なるランダムな別種に変化します。</p>
        </div>

        <div className="rounded-2xl shadow bg-white p-3 max-h-64 overflow-auto">
          <h2 className="font-semibold mb-2">ログ</h2>
          <ol className="text-sm space-y-1">
            {log.map((l,idx)=> <li key={idx}>{l}</li>)}
          </ol>
        </div>
      </div>
    </div>

    <aside className="md:col-span-1">
      <div className="rounded-2xl shadow bg-white p-4 sticky top-4">
        <h2 className="font-semibold mb-2">ルール（MVP実装）</h2>
        <ul className="list-disc pl-5 text-sm space-y-1">
          <li>通常チェス + 転生フェーズ。</li>
          <li>自分の手番開始時、直前までに自分が取られていれば、1体だけ自陣最奥列の空きへ蘇生。</li>
          <li>蘇生する種はキングを除く5種から、元種と異なるランダム。</li>
          <li>空きがなければスキップ（次回に持ち越し）。</li>
          <li>プロモーションはUIで選択（既定はクイーン）。</li>
        </ul>
        <h3 className="font-semibold mt-4 mb-1">AI</h3>
        <p className="text-sm">1手読み + 素材点 + 捕獲で相手に与える転生期待値のペナルティ考慮。</p>
        <button className="mt-4 w-full px-3 py-2 rounded-2xl bg-neutral-900 text-white" onClick={resetGame}>リセット</button>
      </div>
    </aside>
  </div>
</div>

); }

