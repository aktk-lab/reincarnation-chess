<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>転生チェス（Reincarnation Chess）MVP</title>

  <!-- chessboard.js のCSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard.js/1.0.0/chessboard-1.0.0.min.css" integrity="sha512-e1z9v8uLq9wE6K1t1y0H0zUvdR3+QyN6h4+Kp7m7Z7Jqv0gk6w2wQv3y3wQ3u2h7bP7z1nP3m0QH2kEJ9rXfVg==" crossorigin="anonymous" referrerpolicy="no-referrer" />

  <style>
    :root { --bg:#f6f6f6; --card:#fff; --ink:#111; --muted:#6b7280; }
    html,body { margin:0; background:var(--bg); color:var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .wrap { max-width:1100px; margin:0 auto; padding:16px; }
    .grid { display:grid; gap:16px; grid-template-columns: 1fr; }
    @media (min-width: 920px){ .grid { grid-template-columns: 2fr 1fr; } }
    .card { background:var(--card); border-radius:16px; box-shadow:0 6px 16px rgba(0,0,0,.06); padding:16px; }
    .row { display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap; }
    .title { font-weight:700; font-size:22px; }
    .btn { border:1px solid #e5e7eb; background:#fff; border-radius:999px; padding:8px 12px; cursor:pointer; }
    .btn.primary { background:#111; color:#fff; }
    .small { font-size:12px; color:var(--muted); }
    .seg { display:flex; gap:4px; border:1px solid #e5e7eb; border-radius:999px; padding:3px; background:#fff; }
    .seg button { padding:4px 10px; border:none; background:transparent; border-radius:999px; cursor:pointer; }
    .seg button.active { background:#111; color:#fff; }
    .status { font-size:14px; }
    .queue li { display:flex; align-items:center; gap:8px; font-size:14px; }
    .dot { width:8px; height:8px; border-radius:999px; display:inline-block; }
    .dot.w { background:#3b82f6; } .dot.b { background:#ef4444; }
    .log { max-height:260px; overflow:auto; font-size:14px; }
    #board { max-width: 640px; margin: 0 auto; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="row" style="margin-bottom:10px">
      <div class="title">転生チェス（Reincarnation Chess）MVP</div>
      <div class="row">
        <div class="small">昇格先</div>
        <div class="seg" id="promo-seg">
          <button data-p="q" class="active">クイーン</button>
          <button data-p="r">ルーク</button>
          <button data-p="b">ビショップ</button>
          <button data-p="n">ナイト</button>
        </div>
        <button id="btn-reset" class="btn">新規ゲーム</button>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <div id="board"></div>
        <div class="row" style="margin-top:10px">
          <div class="status" id="status">白の手番</div>
        </div>
      </div>

      <div class="card">
        <h3 style="margin:0 0 8px 0; font-size:16px">転生待ちキュー</h3>
        <ul id="queue" class="queue" style="margin:0; padding-left:16px"></ul>
        <p class="small">※ キングには転生しません。配置は自陣最奥列の空きマスへ。元種と異なるランダムな別種に変化します。</p>

        <h3 style="margin:16px 0 8px 0; font-size:16px">ログ</h3>
        <ol id="log" class="log" style="margin:0; padding-left:18px"></ol>

        <h3 style="margin:16px 0 8px 0; font-size:16px">ルール（MVP）</h3>
        <ul class="small" style="margin:0; padding-left:18px; line-height:1.5">
          <li>通常チェス + 「手番開始時の転生」フェーズ。</li>
          <li>自分が直前までに取られていれば、1体だけ自陣最奥列の空きへ蘇生。</li>
          <li>蘇生する種はキング除外の5種から、元種と異なるランダム。</li>
          <li>空きがなければスキップ（次回に持ち越し）。</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- 依存ライブラリ（UMD/非モジュール版） -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard.js/1.0.0/chessboard-1.0.0.min.js" integrity="sha512-Jv3wGqk3fG7o/lVd8sC8ZzJqS6kT5N6mQ0o0zYw0K2zX3X2w0h1tf8g8q8Qm7A5n8q3C9j6z2k7pS7QfG8jQtA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdn.jsdelivr.net/npm/chess.js@1.0.0/dist/chess.min.js"></script>

  <script>
    // --- 設定 --------------------------------------------------------------
    const HUMAN = 'w'; // 人間＝白
    const BACK = { w: ['a1','b1','c1','d1','e1','f1','g1','h1'], b: ['a8','b8','c8','d8','e8','f8','g8','h8'] };
    const LABEL = { p:'ポーン', n:'ナイト', b:'ビショップ', r:'ルーク', q:'クイーン', k:'キング' };
    const pieceName = t => LABEL[t] || t;
    const pick = arr => arr[Math.floor(Math.random()*arr.length)];
    const opposite = c => c==='w'?'b':'w';
    const val = { p:1, n:3, b:3, r:5, q:9 };
    const expectedEV = (original) => {
      const pool = ['p','n','b','r','q'].filter(t => t !== original);
      return pool.reduce((a,t)=>a+val[t],0)/pool.length;
    };

    // --- 状態 --------------------------------------------------------------
    let game = new Chess();       // ルールエンジン
    let board = null;             // 盤UI
    let queue = [];               // [{color, original, id}]
    let promo = 'q';              // 昇格先

    // --- UI DOM -----------------------------------------------------------
    const statusEl = document.getElementById('status');
    const queueEl  = document.getElementById('queue');
    const logEl    = document.getElementById('log');

    document.getElementById('btn-reset').addEventListener('click', resetGame);
    document.querySelectorAll('#promo-seg button').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        document.querySelectorAll('#promo-seg button').forEach(b=>b.classList.remove('active'));
        btn.classList.add('active');
        promo = btn.dataset.p;
      });
    });

    function updateStatus(){
      let s = game.isCheckmate() ? 'チェックメイト！'
            : game.isStalemate() ? 'ステイルメイト'
            : game.isDraw()      ? '引き分け'
            : (game.turn()==='w'?'白':'黒') + ' の手番';
      if (game.isCheck() && !game.isCheckmate()) s += '（チェック中）';
      statusEl.textContent = s;
    }
    function renderQueue(){
      queueEl.innerHTML = '';
      if (!queue.length){
        const li = document.createElement('li');
        li.innerHTML = '<span class="small" style="color:var(--muted)">（なし）</span>';
        queueEl.appendChild(li);
        return;
      }
      queue.forEach((q,i)=>{
        const li = document.createElement('li');
        li.innerHTML = `<span class="dot ${q.color}"></span> ${i+1}. ${q.color==='w'?'白':'黒'}：${pieceName(q.original)} が次手番に転生`;
        queueEl.appendChild(li);
      });
    }
    function log(line){
      const li = document.createElement('li');
      li.textContent = line;
      logEl.insertBefore(li, logEl.firstChild);
    }

    // --- 転生 --------------------------------------------------------------
    function reincarnateIfAny(color){
      const idx = queue.findIndex(q => q.color === color);
      if (idx === -1) return false;
      const empty = BACK[color].filter(sq => !game.get(sq));
      if (!empty.length) return false;

      const item = queue[idx];
      const pool = ['p','n','b','r','q'].filter(t => t !== item.original);
      const newType = pick(pool);
      const square  = pick(empty);

      // chess.js v1.0.0 は put をサポート
      game.put({ type:newType, color }, square);

      queue.splice(idx,1);
      board.position(game.fen(), true);
      log(`【転生】${color==='w'?'白':'黒'}の${pieceName(item.original)}が ${square} に ${pieceName(newType)} として復活。`);
      renderQueue();
      return true;
    }

    // --- AI ---------------------------------------------------------------
    function aiMaterial(forColor){
      let s=0;
      for (const row of game.board()){
        for (const c of row){
          if (!c || c.color!==forColor || c.type==='k') continue;
          s += val[c.type];
        }
      }
      return s;
    }
    function aiEval(move){
      const clone = new Chess(game.fen());
      const r = clone.move(move);
      if (!r) return -999;
      if (clone.isCheckmate()) return 1000;
      if (clone.isStalemate()) return 0;
      const mat = aiMaterial('b') - aiMaterial('w');
      const penalty = r.captured ? expectedEV(r.captured) : 0;
      return mat - penalty*0.8;
    }
    function aiTurn(){
      if (game.game_over() || game.turn()!=='b') return;

      // 転生→着手
      reincarnateIfAny('b');

      const moves = game.moves({ verbose:true });
      if (!moves.length) { updateStatus(); return; }

      let best = moves[0], bestScore = -Infinity;
      for (const m of moves){
        const s = aiEval(m);
        if (s > bestScore){ bestScore = s; best = m; }
      }

      doMove(best.from, best.to, best.promotion);

      // AIの手が終わったら白手番開始＝白の転生
      if (game.turn()==='w'){
        reincarnateIfAny('w');
      }
      updateStatus();
    }

    // --- 移動共通処理 -----------------------------------------------------
    function doMove(from, to, promotion){
      const res = game.move({ from, to, promotion });
      if (!res) return false;

      if (res.captured){
        const capturedType = res.captured;
        const capturedColor = res.color === 'w' ? 'b' : 'w';
        queue.push({ color: capturedColor, original: capturedType, id: `${Date.now()}-${Math.random()}` });
        log(`【捕獲】${res.color==='w'?'白':'黒'} が ${res.to} で ${capturedColor==='w'?'白':'黒'}の ${pieceName(capturedType)} を取った。`);
        renderQueue();
      }
      log(`【着手】${res.color==='w'?'白':'黒'}: ${res.san}`);
      board.position(game.fen(), true);
      return true;
    }

    // --- chessboard.js のイベント -----------------------------------------
    function onDragStart (source, piece, position, orientation) {
      // ゲーム終局 or 自分の手番じゃない or 逆サイドの駒 → 拒否
      if (game.game_over()) return false;
      if (game.turn() !== HUMAN) return false;
      if ((HUMAN === 'w' && piece.startsWith('b')) || (HUMAN === 'b' && piece.startsWith('w'))) return false;
    }

    function onDrop (source, target) {
      // 昇格判定（自動で選択した駒に昇格）
      const moving = game.get(source);
      const isPromo = moving && moving.type==='p' &&
        ((HUMAN==='w' && /8$/.test(target)) || (HUMAN==='b' && /1$/.test(target)));

      const move = { from: source, to: target, promotion: isPromo ? promo : undefined };
      const result = game.move(move);

      if (result === null) return 'snapback'; // 非合法
      // 戻して共通処理で進める（棋譜やキュー処理のため）
      game.undo();
      doMove(source, target, isPromo ? promo : undefined);

      // 人間の手が終わったら黒手番開始＝黒の転生→AI着手
      setTimeout(()=> {
        reincarnateIfAny('b');
        updateStatus();
        setTimeout(aiTurn, 140);
      }, 120);
    }

    function onSnapEnd () {
      board.position(game.fen());
    }

    // --- 初期化 ------------------------------------------------------------
    function resetGame(){
      game = new Chess();
      queue = [];
      board.position('start');
      logEl.innerHTML = '';
      log('新規ゲーム開始。白の手番。');
      renderQueue();
      updateStatus();
    }

    function init(){
      const size = Math.min(640, (typeof window!=='undefined' ? window.innerWidth : 640) - 48);
      board = Chessboard('board', {
        position: 'start',
        draggable: true,
        pieceTheme: 'https://cdnjs.cloudflare.com/ajax/libs/chessboard.js/1.0.0/img/chesspieces/wikipedia/{piece}.png',
        onDragStart,
        onDrop,
        onSnapEnd
      });
      // 初期表示
      renderQueue();
      log('新規ゲーム開始。白の手番。');
      updateStatus();
    }

    window.addEventListener('load', init);
    window.addEventListener('resize', () => board && board.resize());
  </script>
</body>
</html>
