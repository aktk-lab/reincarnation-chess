<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>転生チェス（Reincarnation Chess）MVP</title>

  <!-- 盤UIライブラリ（chessboard.js） -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard.js/1.0.0/chessboard-1.0.0.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />

  <style>
    :root { --bg:#eef6f2; --card:#fff; --ink:#0b1320; --muted:#60707f; }
    html,body { margin:0; background:var(--bg); color:var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .wrap { max-width:1150px; margin:0 auto; padding:16px; }
    .row { display:flex; align-items:center; gap:12px; flex-wrap:wrap; }
    .title { font-size:28px; font-weight:800; letter-spacing:.2px; margin-right:auto; }
    .select, .btn { border:1px solid #e5e7eb; background:#fff; border-radius:12px; padding:10px 12px; font-size:14px; }
    .btn { cursor:pointer; box-shadow:0 2px 6px rgba(0,0,0,.06); }
    .grid { display:grid; gap:16px; grid-template-columns: 1fr; }
    @media (min-width: 980px){ .grid { grid-template-columns: 2fr 1fr; } }
    .card { background:var(--card); border-radius:16px; box-shadow:0 10px 24px rgba(0,0,0,.08); padding:16px; }
    h3 { margin:0 0 10px 0; font-size:18px; }
    .small { font-size:12px; color:var(--muted); }
    .stack { display:flex; flex-direction:column; gap:12px; }
    .queue li { display:flex; align-items:center; gap:8px; font-size:14px; }
    .dot { width:8px; height:8px; border-radius:999px; display:inline-block; }
    .dot.w { background:#3b82f6; } .dot.b { background:#ef4444; }
    .log { max-height:300px; overflow:auto; font-size:14px; border:1px dashed #e5e7eb; border-radius:12px; padding:10px; background:#fafafa; }
    .toolbar { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .seg { display:flex; gap:4px; border:1px solid #e5e7eb; border-radius:999px; padding:3px; background:#fff; }
    .seg button { padding:4px 10px; border:none; background:transparent; border-radius:999px; cursor:pointer; font-size:13px; }
    .seg button.active { background:#0b1320; color:#fff; }
    #board { max-width: 720px; margin: 0 auto; }
    .status { font-size:14px; }
    .section-title { font-weight:700; margin:8px 0 12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- ヘッダー -->
    <div class="row" style="margin-bottom:12px">
      <div class="title">転生チェス — Reincarnation Chess (MVP)</div>
      <label class="row" style="gap:6px">
        <span class="small">Side</span>
        <select id="side" class="select">
          <option value="w">White（先手）</option>
          <option value="b">Black（後手）</option>
        </select>
      </label>
      <button id="newgame" class="btn">New Game</button>
    </div>

    <div class="grid">
      <!-- 左：盤 -->
      <div class="card">
        <div class="row" style="justify-content:space-between; margin-bottom:10px">
          <h3 style="margin:0">Board</h3>
          <div class="toolbar">
            <span class="small">昇格先</span>
            <div class="seg" id="promo-seg">
              <button data-p="q" class="active">Q</button>
              <button data-p="r">R</button>
              <button data-p="b">B</button>
              <button data-p="n">N</button>
            </div>
          </div>
        </div>
        <div id="board"></div>
        <div class="row" style="margin-top:10px; justify-content:space-between">
          <div class="status" id="status">白の手番</div>
        </div>
      </div>

      <!-- 右：キュー/ログ/ルール -->
      <div class="stack">
        <div class="card">
          <div class="section-title">転生待ちキュー</div>
          <ul id="queue" class="queue" style="margin:0; padding-left:16px"></ul>
          <p class="small" style="margin-top:8px">※ キングには転生しません。配置は自陣最奥列の空きマスへ。元種と異なるランダムな別種に変化します。</p>
        </div>

        <div class="card">
          <div class="section-title">ログ</div>
          <ol id="log" class="log" style="margin:0; padding-left:18px"></ol>
        </div>

        <div class="card">
          <div class="section-title">ルール（MVP）</div>
          <ul class="small" style="margin:0; padding-left:18px; line-height:1.5">
            <li>通常チェス + 「手番開始時の転生」フェーズ。</li>
            <li>自分が直前までに取られていれば、1体だけ自陣最奥列の空きへ蘇生。</li>
            <li>蘇生する種はキング除外の5種から、元種と異なるランダム。</li>
            <li>空きがなければスキップ（次回に持ち越し）。</li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <!-- 依存ライブラリ -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard.js/1.0.0/chessboard-1.0.0.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdn.jsdelivr.net/npm/chess.js@1.0.0/dist/chess.min.js"></script>

  <script>
    // ===== 基本設定 =====
    const BACK = { w: ['a1','b1','c1','d1','e1','f1','g1','h1'], b: ['a8','b8','c8','d8','e8','f8','g8','h8'] };
    const LABEL = { p:'ポーン', n:'ナイト', b:'ビショップ', r:'ルーク', q:'クイーン', k:'キング' };
    const pieceName = t => LABEL[t] || t;
    const pick = arr => arr[Math.floor(Math.random()*arr.length)];
    const opposite = c => c==='w'?'b':'w';
    const val = { p:1, n:3, b:3, r:5, q:9 };
    const expectedEV = (original) => {
      const pool = ['p','n','b','r','q'].filter(t => t !== original);
      return pool.reduce((a,t)=>a+val[t],0)/pool.length;
    };

    // ===== 状態 =====
    let HUMAN = 'w';          // 人間の色
    let game = new Chess();   // ルール
    let board = null;         // 盤UI
    let queue = [];           // 転生待ち [{color, original, id}]
    let promo = 'q';          // 昇格先

    // ===== DOM =====
    const statusEl = document.getElementById('status');
    const queueEl  = document.getElementById('queue');
    const logEl    = document.getElementById('log');

    document.getElementById('newgame').addEventListener('click', () => startNew(document.getElementById('side').value));
    document.getElementById('side').addEventListener('change', (e)=> startNew(e.target.value));
    document.querySelectorAll('#promo-seg button').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        document.querySelectorAll('#promo-seg button').forEach(b=>b.classList.remove('active'));
        btn.classList.add('active'); promo = btn.dataset.p;
      });
    });

    // ===== 表示系 =====
    function updateStatus(textExtra=''){
      let s = game.isCheckmate() ? 'チェックメイト！'
            : game.isStalemate() ? 'ステイルメイト'
            : game.isDraw()      ? '引き分け'
            : (game.turn()==='w'?'白':'黒') + ' の手番';
      if (game.isCheck() && !game.isCheckmate()) s += '（チェック中）';
      if (textExtra) s += textExtra;
      statusEl.textContent = s;
    }
    function renderQueue(){
      queueEl.innerHTML = '';
      if (!queue.length){
        const li = document.createElement('li');
        li.innerHTML = '<span class="small" style="color:#60707f">（なし）</span>';
        queueEl.appendChild(li);
        return;
      }
      queue.forEach((q,i)=>{
        const li = document.createElement('li');
        li.innerHTML = `<span class="dot ${q.color}"></span> ${i+1}. ${q.color==='w'?'白':'黒'}：${pieceName(q.original)} が次手番に転生`;
        queueEl.appendChild(li);
      });
    }
    function log(line){
      const li = document.createElement('li');
      li.textContent = line;
      logEl.insertBefore(li, logEl.firstChild);
    }

    // ===== 転生 =====
    function reincarnateIfAny(color){
      const idx = queue.findIndex(q => q.color === color);
      if (idx === -1) return false;
      const empty = BACK[color].filter(sq => !game.get(sq));
      if (!empty.length) return false;

      const item = queue[idx];
      const pool = ['p','n','b','r','q'].filter(t => t !== item.original);
      const newType = pick(pool);
      const square  = pick(empty);

      game.put({ type:newType, color }, square);
      queue.splice(idx,1);
      board.position(game.fen(), true);
      log(`【転生】${color==='w'?'白':'黒'}の${pieceName(item.original)}が ${square} に ${pieceName(newType)} として復活。`);
      renderQueue();
      return true;
    }

    // ===== AI =====
    function aiMaterial(forColor){
      let s=0;
      for (const row of game.board()){
        for (const c of row){
          if (!c || c.color!==forColor || c.type==='k') continue;
          s += val[c.type];
        }
      }
      return s;
    }
    function aiEval(move){
      const clone = new Chess(game.fen());
      const r = clone.move(move);
      if (!r) return -999;
      if (clone.isCheckmate()) return 1000;
      if (clone.isStalemate()) return 0;
      const mat = aiMaterial('b') - aiMaterial('w');
      const penalty = r.captured ? expectedEV(r.captured) : 0;
      return mat - penalty*0.8;
    }
    function aiTurn(){
      if (game.game_over() || game.turn()!=='b') return;
      reincarnateIfAny('b');         // AI手番開始 → 転生
      const moves = game.moves({ verbose:true });
      if (!moves.length){ updateStatus(); return; }
      let best = moves[0], bestScore = -Infinity;
      for (const m of moves){ const s = aiEval(m); if (s > bestScore){ bestScore = s; best = m; } }
      doMove(best.from, best.to, best.promotion);
      if (game.turn()==='w'){        // AIの手後、白手番開始 → 白の転生
        reincarnateIfAny('w');
      }
      updateStatus();
    }

    // ===== 共通：指し手適用 =====
    function doMove(from, to, promotion){
      const res = game.move({ from, to, promotion });
      if (!res) return false;

      if (res.captured){
        const capturedType = res.captured;
        const capturedColor = res.color === 'w' ? 'b' : 'w';
        queue.push({ color: capturedColor, original: capturedType, id: `${Date.now()}-${Math.random()}` });
        log(`【捕獲】${res.color==='w'?'白':'黒'} が ${res.to} で ${capturedColor==='w'?'白':'黒'}の ${pieceName(capturedType)} を取った。`);
        renderQueue();
      }
      log(`【着手】${res.color==='w'?'白':'黒'}: ${res.san}`);
      board.position(game.fen(), true);
      return true;
    }

    // ===== 盤UIイベント =====
    function onDragStart (source, piece) {
      if (game.game_over()) return false;
      if (game.turn() !== HUMAN) return false;
      if ((HUMAN === 'w' && piece.startsWith('b')) || (HUMAN === 'b' && piece.startsWith('w'))) return false;
    }
    function onDrop (source, target) {
      // 昇格判定
      const moving = game.get(source);
      const isPromo = moving && moving.type==='p' &&
        ((HUMAN==='w' && /8$/.test(target)) || (HUMAN==='b' && /1$/.test(target)));

      const tryMove = { from: source, to: target, promotion: isPromo ? promo : undefined };
      const result = game.move(tryMove);
      if (result === null) return 'snapback'; // 非合法
      game.undo(); // 共通処理のため一旦戻す
      doMove(source, target, isPromo ? promo : undefined);

      // 人間手後 → 相手手番開始：相手の転生→AI着手
      setTimeout(()=> {
        if (HUMAN==='w'){ // 相手は黒
          reincarnateIfAny('b');
          updateStatus();
          setTimeout(aiTurn, 140);
        } else {          // 相手は白（HUMANは黒）＝AIが先手
          // 次の手番は白→ ここではAIではなく、白の手が終わっているので黒手番開始＝黒の転生
          reincarnateIfAny('w'); // 念のため白側も処理（通常ここは不要）
        }
      }, 120);
    }
    function onSnapEnd () { board.position(game.fen()); }

    // ===== 新規開始 =====
    function startNew(side){
      HUMAN = side; queue = []; game = new Chess();
      const orient = (HUMAN==='w') ? 'white' : 'black';
      board.orientation(orient);
      board.position('start', false);
      logEl.innerHTML = ''; log('新規ゲーム開始。' + (HUMAN==='w'?'白':'黒') + 'でプレイ。');
      renderQueue(); updateStatus();

      // 先手がAIの場合（HUMAN=黒）→ 白の手番でAIが指す前に白の転生
      if (HUMAN==='b'){
        setTimeout(()=>{
          reincarnateIfAny('w'); // 白の転生（置けなければ何も起きない）
          updateStatus('（AI思考中…）');
          setTimeout(()=>{
            // 白＝AIで1手指す
            const moves = game.moves({ verbose:true });
            if (moves.length){
              // シンプルに最良手を選ぶ（白側評価に合わせて符号反転）
              let best=moves[0], bestScore=-Infinity;
              for (const m of moves){
                const clone = new Chess(game.fen()); const r=clone.move(m);
                if (!r) continue;
                let score = (aiMaterial('w') - aiMaterial('b')) - (r.captured?expectedEV(r.captured):0)*0.8;
                if (clone.isCheckmate()) score = 1000;
                if (clone.isStalemate()) score = 0;
                if (score>bestScore){ bestScore=score; best=m; }
              }
              doMove(best.from, best.to, best.promotion);
            }
            // 黒（人間）手番開始 → 黒の転生
            if (game.turn()==='b') { reincarnateIfAny('b'); }
            updateStatus();
          }, 180);
        }, 120);
      }
    }

    // ===== 初期化 =====
    function init(){
      board = Chessboard('board', {
        position: 'start',
        draggable: true,
        pieceTheme: 'https://cdnjs.cloudflare.com/ajax/libs/chessboard.js/1.0.0/img/chesspieces/wikipedia/{piece}.png',
        onDragStart, onDrop, onSnapEnd,
        orientation: 'white'
      });
      renderQueue(); log('新規ゲーム開始。白の手番。'); updateStatus();
      // レスポンシブ
      window.addEventListener('resize', () => board && board.resize());
    }
    window.addEventListener('load', init);
  </script>
</body>
</html>
